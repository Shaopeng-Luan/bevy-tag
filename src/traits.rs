//! Traits for namespace tags and GID conversion.
//!
//! These traits are implemented by types generated from the `namespace!` macro,
//! enabling zero-cost conversion from typed tags to GID.

use core::marker::PhantomData;

use crate::registry::NamespaceRegistry;
use crate::GID;

// =============================================================================
// Alias<T> — zero-cost wrapper for deprecated/aliased tags
// =============================================================================

/// A zero-cost wrapper indicating this tag is an alias of another tag.
///
/// When a tag is renamed or moved, the old path can be kept as an alias
/// pointing to the new tag. The `Alias<T>` type makes this relationship
/// explicit in the type system.
///
/// ```rust,ignore
/// namespace! {
///     pub mod Tags {
///         // New canonical path
///         Equipment {
///             Blade;
///         }
///         // Old path kept as alias
///         #[alias_of = "Equipment.Blade"]
///         Item {
///             Weapon {
///                 Sword;  // This becomes Alias<Equipment::Blade::Tag>
///             }
///         }
///     }
/// }
///
/// // Both have the same GID:
/// assert_eq!(
///     Tags::Item::Weapon::Sword::Tag::STABLE_GID,
///     Tags::Equipment::Blade::Tag::STABLE_GID
/// );
/// ```
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Alias<T: NamespaceTag>(PhantomData<T>);

impl<T: NamespaceTag> Alias<T> {
    /// Create a new alias instance.
    #[inline]
    pub const fn new() -> Self {
        Self(PhantomData)
    }
}

impl<T: NamespaceTag> Default for Alias<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

impl<T: NamespaceTag> core::fmt::Debug for Alias<T> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "Alias<{}>", T::PATH)
    }
}

impl<T: NamespaceTag> NamespaceTag for Alias<T> {
    /// The path of the ALIAS (not the target).
    /// This is set by the macro when generating the alias.
    const PATH: &'static str = T::PATH;

    /// Depth matches the target.
    const DEPTH: u8 = T::DEPTH;

    /// GID matches the target — this is the key invariant.
    const STABLE_GID: GID = T::STABLE_GID;
}

impl<T: NamespaceTag + HasData> HasData for Alias<T> {
    type Data = T::Data;
}

/// A compile-time namespace tag, generated by the `namespace!` macro.
///
/// Each node in the namespace tree gets a zero-sized Tag type with
/// associated constants for path, depth, and stable GID.
///
/// ```rust,ignore
/// namespace! {
///     pub mod ids {
///         Movement { Idle; Running; }
///     }
/// }
///
/// // Generated:
/// // ids::Movement::Idle::Tag implements NamespaceTag
/// // ids::Movement::Idle::Tag::PATH  = "Movement.Idle"
/// // ids::Movement::Idle::Tag::DEPTH = 1
/// // ids::Movement::Idle::Tag::GID   = 0x... (const hierarchical hash)
/// ```
pub trait NamespaceTag: Copy + 'static {
    /// Full dot-separated path, e.g. `"Movement.Idle"`.
    const PATH: &'static str;

    /// Depth in the tree (0 = top-level).
    const DEPTH: u8;

    /// Stable hierarchical GID, computed at compile time.
    ///
    /// This is a `const` value — no registry lookup needed.
    const STABLE_GID: GID;

    /// Get the GID. This is just `Self::STABLE_GID` but useful
    /// when you have a value (not just the type).
    #[inline]
    fn gid() -> GID {
        Self::STABLE_GID
    }
}

// =============================================================================
// IntoGid — uniform conversion to GID
// =============================================================================

/// Convert to GID. Implemented for raw `GID` (passthrough) and all `NamespaceTag` types.
pub trait IntoGid: Copy {
    fn into_gid(self) -> GID;
}

impl IntoGid for GID {
    #[inline]
    fn into_gid(self) -> GID {
        self
    }
}

impl<T: NamespaceTag> IntoGid for T {
    #[inline]
    fn into_gid(self) -> GID {
        T::STABLE_GID
    }
}

// =============================================================================
// IntoGidWithRegistry — for contexts with a local (non-global) registry
// =============================================================================

/// Convert to GID using a specific registry instance.
///
/// Useful for ECS integrations where the registry is a `Res<NamespaceRegistry>`.
pub trait IntoGidWithRegistry: Copy {
    fn into_gid_with(self, registry: &NamespaceRegistry) -> GID;
}

impl IntoGidWithRegistry for GID {
    #[inline]
    fn into_gid_with(self, _registry: &NamespaceRegistry) -> GID {
        self
    }
}

impl<T: NamespaceTag> IntoGidWithRegistry for T {
    #[inline]
    fn into_gid_with(self, _registry: &NamespaceRegistry) -> GID {
        // Tag already knows its GID at compile time
        T::STABLE_GID
    }
}

// =============================================================================
// IntoGids — batch conversion
// =============================================================================

/// Convert a collection of items into a `Vec<GID>`.
pub trait IntoGids {
    fn into_gids(self) -> Vec<GID>;
}

impl<T: IntoGid> IntoGids for Vec<T> {
    #[inline]
    fn into_gids(self) -> Vec<GID> {
        self.into_iter().map(IntoGid::into_gid).collect()
    }
}

// Tuple impls for ergonomic multi-id passing (up to 12 elements)
macro_rules! impl_into_gids_tuple {
    ($($idx:tt $T:ident),+) => {
        impl<$($T: IntoGid),+> IntoGids for ($($T,)+) {
            #[inline]
            fn into_gids(self) -> Vec<GID> {
                vec![$(self.$idx.into_gid()),+]
            }
        }
    };
}

impl_into_gids_tuple!(0 A, 1 B);
impl_into_gids_tuple!(0 A, 1 B, 2 C);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J, 10 K);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J, 10 K, 11 L);

// Const array support
impl<T: IntoGid, const N: usize> IntoGids for [T; N] {
    #[inline]
    fn into_gids(self) -> Vec<GID> {
        self.into_iter().map(IntoGid::into_gid).collect()
    }
}

// =============================================================================
// HasData — marker trait for tags with associated data types
// =============================================================================

/// Marker trait for namespace tags that have associated serializable data.
///
/// This trait is automatically implemented by the `namespace!` macro when
/// a node is declared with a type parameter:
///
/// ```rust,ignore
/// namespace! {
///     pub mod ids {
///         Movement<MovementData>;  // generates HasData impl
///         Combat;                  // no HasData impl
///     }
/// }
/// ```
///
/// The associated `Data` type must implement `serde::Serialize + serde::Deserialize`.
pub trait HasData: NamespaceTag {
    /// The data type associated with this namespace tag.
    type Data: serde::Serialize + for<'de> serde::Deserialize<'de>;
}