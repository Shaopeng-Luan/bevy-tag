//! Code generation for namespace! macro.

use crate::lock::LockFile;
use crate::toml_parser::TagsConfig;
use std::collections::HashMap;

/// Deprecation info for code generation.
#[derive(Debug, Default, Clone)]
struct DeprecationInfo {
    /// Whether this path is deprecated
    deprecated: bool,
    /// If set, this path is an alias of another path (generates type alias instead of full Tag)
    alias_of: Option<String>,
}

/// Redirect info for code generation.
#[derive(Debug, Clone)]
struct RedirectInfo {
    /// Target path to redirect to
    target: String,
}

/// Generate Rust code that invokes the `namespace!` macro.
///
/// Output looks like:
/// ```ignore
/// // AUTO-GENERATED by bevy-tag-build - DO NOT EDIT
/// use bevy_tag_macro::namespace;
///
/// namespace! {
///     pub mod Tags {
///         Item {
///             Weapon {
///                 Sword;
///                 Axe;
///             }
///         }
///         Skill {
///             Combat;
///         }
///     }
/// }
/// ```
pub fn generate_namespace_code(config: &TagsConfig) -> String {
    // Build redirect map from config
    let redirect_map: HashMap<&str, RedirectInfo> = config
        .redirects()
        .map(|r| (r.from.as_str(), RedirectInfo { target: r.to.clone() }))
        .collect();

    generate_namespace_code_internal(config, &HashMap::new(), &redirect_map)
}

/// Generate Rust code from lock file (includes deprecated entries).
pub fn generate_namespace_code_from_lock(config: &TagsConfig, lock: &LockFile) -> String {
    let deprecation_map: HashMap<&str, DeprecationInfo> = lock
        .entries
        .iter()
        .filter(|e| e.deprecated)
        .map(|e| {
            (
                e.path.as_str(),
                DeprecationInfo {
                    deprecated: true,
                    alias_of: e.equivalent_to.clone(),
                },
            )
        })
        .collect();

    // Build redirect map from config
    let redirect_map: HashMap<&str, RedirectInfo> = config
        .redirects()
        .map(|r| (r.from.as_str(), RedirectInfo { target: r.to.clone() }))
        .collect();

    generate_namespace_code_internal(config, &deprecation_map, &redirect_map)
}

/// Generate code with optional deprecated markers and redirects.
fn generate_namespace_code_internal(
    config: &TagsConfig,
    deprecation_map: &HashMap<&str, DeprecationInfo>,
    redirect_map: &HashMap<&str, RedirectInfo>,
) -> String {
    let mut output = String::new();

    // Header
    output.push_str("// AUTO-GENERATED by bevy-tag-build - DO NOT EDIT\n");
    output.push_str("// Source: tags.toml\n\n");
    output.push_str("#![allow(non_snake_case)]\n\n");
    output.push_str("use bevy_tag_macro::namespace;\n\n");

    // Build tree structure (from config entries)
    let mut tree = build_tree(config);

    // Also add deprecated paths to tree (they exist in lock but not config)
    for path in deprecation_map.keys() {
        let segments: Vec<&str> = path.split('.').collect();
        insert_path(&mut tree, &segments);
    }

    // Also add redirect source paths to tree
    for path in redirect_map.keys() {
        let segments: Vec<&str> = path.split('.').collect();
        insert_path(&mut tree, &segments);
    }

    // Generate namespace! macro call
    output.push_str("namespace! {\n");
    output.push_str(&format!("    pub mod {} {{\n", config.module_name));

    // Generate tree recursively
    generate_tree_code(&tree, "", 2, deprecation_map, redirect_map, &mut output);

    output.push_str("    }\n");
    output.push_str("}\n");

    // Generate type aliases for deprecated paths with equivalent_to
    let aliases: Vec<_> = deprecation_map
        .iter()
        .filter_map(|(path, info)| {
            info.alias_of.as_ref().map(|target| (*path, target.as_str()))
        })
        .collect();

    if !aliases.is_empty() {
        output.push_str("\n// ══════════════════════════════════════════════════════════════════════════════\n");
        output.push_str("// Redirects for renamed paths\n");
        output.push_str("// ══════════════════════════════════════════════════════════════════════════════\n\n");

        for (old_path, new_path) in aliases {
            let old_rust_path = path_to_rust_path(old_path, &config.module_name);
            let new_rust_path = path_to_rust_path(new_path, &config.module_name);

            output.push_str(&format!(
                "#[deprecated(note = \"redirected to {}\")]\n",
                new_rust_path
            ));
            output.push_str(&format!(
                "pub type {} = bevy_tag::Redirect<{}>;\n\n",
                old_rust_path.replace("::", "_"),  // Flatten for top-level type alias
                new_rust_path
            ));
        }
    }

    output
}

/// Convert CamelCase to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Convert dot-separated path to Rust module path.
///
/// Uses the new naming convention:
/// - CamelCase struct for the tag itself
/// - snake_case module for accessing children
///
/// Examples:
/// - "Sword" -> "Tags::Sword" (leaf at root)
/// - "Item.Weapon.Sword" -> "Tags::item::weapon::Sword" (nested leaf)
/// - "Item" -> "Tags::Item" (branch at root)
fn path_to_rust_path(path: &str, module_name: &str) -> String {
    let segments: Vec<&str> = path.split('.').collect();

    if segments.len() == 1 {
        // Root level: direct access
        format!("{}::{}", module_name, segments[0])
    } else {
        // Nested: use snake_case modules for parents, CamelCase for the final segment
        let parents: Vec<String> = segments[..segments.len() - 1]
            .iter()
            .map(|s| to_snake_case(s))
            .collect();
        let leaf = segments.last().unwrap();
        format!("{}::{}::{}", module_name, parents.join("::"), leaf)
    }
}

/// Tree node for code generation.
#[derive(Debug, Default)]
struct TreeNode {
    /// Child nodes by segment name
    children: HashMap<String, TreeNode>,
}

/// Build a tree from flat paths.
fn build_tree(config: &TagsConfig) -> TreeNode {
    let mut root = TreeNode::default();

    for entry in config.entries() {
        let segments: Vec<&str> = entry.path.split('.').collect();
        insert_path(&mut root, &segments);
    }

    root
}

/// Insert a path into the tree.
fn insert_path(node: &mut TreeNode, segments: &[&str]) {
    if segments.is_empty() {
        return;
    }

    let child = node
        .children
        .entry(segments[0].to_string())
        .or_default();

    if segments.len() > 1 {
        insert_path(child, &segments[1..]);
    }
}

/// Generate code for a tree node recursively.
fn generate_tree_code(
    node: &TreeNode,
    current_path: &str,
    indent: usize,
    deprecation_map: &HashMap<&str, DeprecationInfo>,
    redirect_map: &HashMap<&str, RedirectInfo>,
    output: &mut String,
) {
    // Sort children for deterministic output
    let mut children: Vec<_> = node.children.iter().collect();
    children.sort_by(|a, b| a.0.cmp(b.0));

    for (name, child) in children {
        let indent_str = "    ".repeat(indent);
        let full_path = if current_path.is_empty() {
            name.clone()
        } else {
            format!("{}.{}", current_path, name)
        };

        // Check if this path is a redirect
        if let Some(redirect_info) = redirect_map.get(full_path.as_str()) {
            // Generate #[redirect = "target"] attribute
            output.push_str(&format!(
                "{}#[redirect = \"{}\"]\n",
                indent_str, redirect_info.target
            ));
            output.push_str(&format!("{}{};\n", indent_str, name));
            continue;
        }

        // Check if this path is deprecated
        let is_deprecated = deprecation_map.get(full_path.as_str())
            .map(|info| info.deprecated)
            .unwrap_or(false);

        // Generate #[deprecated] attribute for Rust native deprecation warnings
        if is_deprecated {
            // Get the alias target if any
            let note = if let Some(info) = deprecation_map.get(full_path.as_str()) {
                if let Some(ref alias_of) = info.alias_of {
                    format!("This tag is deprecated. Use '{}' instead.", alias_of)
                } else {
                    "This tag is deprecated.".to_string()
                }
            } else {
                "This tag is deprecated.".to_string()
            };

            output.push_str(&format!(
                "{}#[deprecated(note = \"{}\")]\n",
                indent_str, note
            ));
        }

        if child.children.is_empty() {
            // Leaf node
            output.push_str(&format!("{}{};\n", indent_str, name));
        } else {
            // Branch node
            output.push_str(&format!("{}{} {{\n", indent_str, name));
            generate_tree_code(child, &full_path, indent + 1, deprecation_map, redirect_map, output);
            output.push_str(&format!("{}}}\n", indent_str));
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_config(paths: &[&str]) -> TagsConfig {
        let toml = format!(
            r#"
[tags]
paths = [{}]
"#,
            paths
                .iter()
                .map(|p| format!("\"{}\"", p))
                .collect::<Vec<_>>()
                .join(", ")
        );
        TagsConfig::from_str(&toml).unwrap()
    }

    #[test]
    fn generate_simple_tree() {
        let config = make_config(&["A.B", "A.C", "X"]);
        let code = generate_namespace_code(&config);

        // Should contain proper structure
        assert!(code.contains("pub mod Tags"));
        assert!(code.contains("A {"));
        assert!(code.contains("B;"));
        assert!(code.contains("C;"));
        assert!(code.contains("X;"));
    }

    #[test]
    fn generate_nested_tree() {
        let config = make_config(&["Item.Weapon.Sword", "Item.Weapon.Axe", "Item.Armor"]);
        let code = generate_namespace_code(&config);

        println!("{}", code);

        assert!(code.contains("Item {"));
        assert!(code.contains("Weapon {"));
        assert!(code.contains("Sword;"));
        assert!(code.contains("Axe;"));
        assert!(code.contains("Armor;"));
    }

    #[test]
    fn generate_with_custom_module_name() {
        let toml = r#"
module_name = "GameTags"

[tags]
paths = ["A"]
"#;
        let config = TagsConfig::from_str(toml).unwrap();
        let code = generate_namespace_code(&config);

        assert!(code.contains("pub mod GameTags"));
    }

    #[test]
    fn output_is_deterministic() {
        let config = make_config(&["Z", "A", "M.X", "M.A"]);

        let code1 = generate_namespace_code(&config);
        let code2 = generate_namespace_code(&config);

        assert_eq!(code1, code2);

        // Should be sorted alphabetically
        let a_pos = code1.find("A {").or(code1.find("A;")).unwrap();
        let z_pos = code1.find("Z;").unwrap();
        assert!(a_pos < z_pos, "A should come before Z");
    }

    #[test]
    fn generate_with_deprecated() {
        let config = make_config(&["A.B"]);
        let mut deprecation_map = HashMap::new();
        deprecation_map.insert("A.C", DeprecationInfo { deprecated: true, alias_of: None });
        deprecation_map.insert("X.Y", DeprecationInfo { deprecated: true, alias_of: None });

        let code = generate_namespace_code_internal(&config, &deprecation_map, &HashMap::new());

        println!("{}", code);

        // Active paths should not be deprecated
        // B is active (not in deprecation_map)
        assert!(code.contains("B;"));

        // Deprecated paths should have #[deprecated(note = "...")]
        assert!(code.contains("#[deprecated(note = \"This tag is deprecated.\")]"));
        assert!(code.contains("C;")); // A.C's node name
        assert!(code.contains("Y;")); // X.Y's node name
    }

    #[test]
    fn deprecated_uses_rust_native_attribute() {
        let config = make_config(&["A"]);
        let mut deprecation_map = HashMap::new();
        deprecation_map.insert("X", DeprecationInfo { deprecated: true, alias_of: None });

        let code = generate_namespace_code_internal(&config, &deprecation_map, &HashMap::new());

        // Check the deprecated attribute format uses Rust native syntax
        assert!(code.contains("#[deprecated(note = "));
    }

    #[test]
    fn generate_with_alias() {
        let config = make_config(&["New.Path"]);
        let mut deprecation_map = HashMap::new();
        deprecation_map.insert("Old.Path", DeprecationInfo {
            deprecated: true,
            alias_of: Some("New.Path".to_string()),
        });

        let code = generate_namespace_code_internal(&config, &deprecation_map, &HashMap::new());

        println!("{}", code);

        // Should have deprecated attribute with alias info
        assert!(code.contains("Use 'New.Path' instead"));

        // Should generate redirect section
        assert!(code.contains("Redirects for renamed paths"));
        assert!(code.contains("bevy_tag::Redirect<"));
    }

    #[test]
    fn generate_with_config_redirects() {
        let toml = r#"
[tags]
paths = ["Equipment.Weapon.Blade"]

[redirects]
"Legacy.OldSword" = "Equipment.Weapon.Blade"
"#;
        let config = TagsConfig::from_str(toml).unwrap();
        let code = generate_namespace_code(&config);

        println!("{}", code);

        // Should contain the redirect attribute
        assert!(code.contains("#[redirect = \"Equipment.Weapon.Blade\"]"));
        assert!(code.contains("OldSword;"));
    }

    #[test]
    fn path_to_rust_path_conversion() {
        // New naming convention: snake_case modules, CamelCase struct
        assert_eq!(
            path_to_rust_path("Item.Weapon.Sword", "Tags"),
            "Tags::item::weapon::Sword"
        );
        assert_eq!(
            path_to_rust_path("Movement", "GameTags"),
            "GameTags::Movement"
        );
        assert_eq!(
            path_to_rust_path("Combat.Attack", "Tags"),
            "Tags::combat::Attack"
        );
    }

    #[test]
    fn snake_case_conversion() {
        assert_eq!(to_snake_case("Item"), "item");
        assert_eq!(to_snake_case("CamelCase"), "camel_case");
        assert_eq!(to_snake_case("HTMLParser"), "h_t_m_l_parser");
        assert_eq!(to_snake_case("simple"), "simple");
    }
}
