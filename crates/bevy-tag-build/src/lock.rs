//! Lock file management for change detection.
//!
//! The lock file records all paths and their computed GIDs.
//! On subsequent builds, we compare the current config against the lock
//! to detect breaking changes (removed paths).

use crate::toml_parser::{TagEntry, TagsConfig};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::path::Path;

/// Current lock file schema version.
const SCHEMA_VERSION: u32 = 1;

/// Lock file contents.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockFile {
    /// Schema version for forward compatibility
    pub schema_version: u32,
    /// When the lock file was generated
    pub generated_at: String,
    /// All locked entries
    #[serde(default)]
    pub entries: Vec<LockEntry>,
}

/// A single locked entry.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct LockEntry {
    /// Full dot-separated path
    pub path: String,
    /// Tree depth
    pub depth: u8,
    /// Parent path (None for root)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    /// Whether this entry is deprecated (removed from config but kept for compatibility)
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub deprecated: bool,
    /// Path of the canonical entry this is equivalent to (for migration/aliasing)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub equivalent_to: Option<String>,
}

/// Difference between lock file and current config.
#[derive(Debug, Default)]
pub struct LockDiff {
    /// Paths that exist in lock but not in config (BREAKING!)
    pub removed: Vec<String>,
    /// Paths that exist in config but not in lock (OK, will be added)
    pub added: Vec<String>,
}

impl LockFile {
    /// Create a new lock file from config.
    pub fn from_config(config: &TagsConfig) -> Self {
        let entries = config
            .entries()
            .map(|e| LockEntry {
                path: e.path.clone(),
                depth: e.depth,
                parent: e.parent.clone(),
                deprecated: false,
                equivalent_to: None,
            })
            .collect();

        Self {
            schema_version: SCHEMA_VERSION,
            generated_at: chrono::Utc::now().to_rfc3339(),
            entries,
        }
    }

    /// Load from a TOML file.
    pub fn from_file(path: impl AsRef<Path>) -> Result<Self, LockFileError> {
        let content = std::fs::read_to_string(path.as_ref()).map_err(|e| {
            LockFileError::Io(format!("Failed to read {}: {}", path.as_ref().display(), e))
        })?;
        Self::from_str(&content)
    }

    /// Parse from a TOML string.
    pub fn from_str(content: &str) -> Result<Self, LockFileError> {
        let lock: LockFile =
            toml::from_str(content).map_err(|e| LockFileError::Parse(e.to_string()))?;

        // Check schema version
        if lock.schema_version > SCHEMA_VERSION {
            return Err(LockFileError::SchemaVersion {
                found: lock.schema_version,
                supported: SCHEMA_VERSION,
            });
        }

        Ok(lock)
    }

    /// Write to a TOML file.
    pub fn write_to_file(&self, path: impl AsRef<Path>) -> Result<(), LockFileError> {
        let header = "# AUTO-GENERATED by bevy-tag-build - DO NOT EDIT MANUALLY\n\
                      # To update: delete this file and rebuild\n\n";

        let content =
            toml::to_string_pretty(self).map_err(|e| LockFileError::Serialize(e.to_string()))?;

        std::fs::write(path.as_ref(), format!("{}{}", header, content)).map_err(|e| {
            LockFileError::Io(format!("Failed to write {}: {}", path.as_ref().display(), e))
        })?;

        Ok(())
    }

    /// Compare against current config.
    pub fn diff(&self, config: &TagsConfig) -> LockDiff {
        let lock_paths: HashSet<_> = self.entries.iter().map(|e| e.path.as_str()).collect();
        let config_paths: HashSet<_> = config.entries().map(|e| e.path.as_str()).collect();

        let removed: Vec<String> = lock_paths
            .difference(&config_paths)
            .map(|s| s.to_string())
            .collect();

        let added: Vec<String> = config_paths
            .difference(&lock_paths)
            .map(|s| s.to_string())
            .collect();

        LockDiff { removed, added }
    }

    /// Add a new entry to the lock file.
    pub fn add_entry(&mut self, entry: TagEntry) {
        // Check if already exists
        if self.entries.iter().any(|e| e.path == entry.path) {
            return;
        }

        self.entries.push(LockEntry {
            path: entry.path,
            depth: entry.depth,
            parent: entry.parent,
            deprecated: false,
            equivalent_to: None,
        });

        // Keep sorted for deterministic output
        self.entries.sort_by(|a, b| a.path.cmp(&b.path));

        // Update timestamp
        self.generated_at = chrono::Utc::now().to_rfc3339();
    }

    /// Mark an entry as deprecated.
    pub fn mark_deprecated(&mut self, path: &str) {
        if let Some(entry) = self.entries.iter_mut().find(|e| e.path == path) {
            entry.deprecated = true;
        }
        self.generated_at = chrono::Utc::now().to_rfc3339();
    }

    /// Get all deprecated entries.
    pub fn deprecated_entries(&self) -> impl Iterator<Item = &LockEntry> {
        self.entries.iter().filter(|e| e.deprecated)
    }

    /// Get all active (non-deprecated) entries.
    pub fn active_entries(&self) -> impl Iterator<Item = &LockEntry> {
        self.entries.iter().filter(|e| !e.deprecated)
    }

    /// Get entry by path.
    pub fn get(&self, path: &str) -> Option<&LockEntry> {
        self.entries.iter().find(|e| e.path == path)
    }

    /// Build a path -> entry map.
    pub fn as_map(&self) -> HashMap<&str, &LockEntry> {
        self.entries.iter().map(|e| (e.path.as_str(), e)).collect()
    }
}

/// Errors during lock file operations.
#[derive(Debug)]
pub enum LockFileError {
    /// IO error
    Io(String),
    /// TOML parse error
    Parse(String),
    /// TOML serialize error
    Serialize(String),
    /// Unsupported schema version
    SchemaVersion { found: u32, supported: u32 },
}

impl std::fmt::Display for LockFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Io(msg) => write!(f, "IO error: {}", msg),
            Self::Parse(msg) => write!(f, "Parse error: {}", msg),
            Self::Serialize(msg) => write!(f, "Serialize error: {}", msg),
            Self::SchemaVersion { found, supported } => {
                write!(
                    f,
                    "Lock file schema version {} is newer than supported version {}. \
                     Please upgrade bevy-tag-build.",
                    found, supported
                )
            }
        }
    }
}

impl std::error::Error for LockFileError {}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_config(paths: &[&str]) -> TagsConfig {
        let toml = format!(
            r#"
[tags]
paths = [{}]
"#,
            paths
                .iter()
                .map(|p| format!("\"{}\"", p))
                .collect::<Vec<_>>()
                .join(", ")
        );
        TagsConfig::from_str(&toml).unwrap()
    }

    #[test]
    fn create_from_config() {
        let config = make_config(&["A.B.C"]);
        let lock = LockFile::from_config(&config);

        assert_eq!(lock.schema_version, SCHEMA_VERSION);
        assert_eq!(lock.entries.len(), 3); // A, A.B, A.B.C
    }

    #[test]
    fn roundtrip_serialization() {
        let config = make_config(&["A.B", "X.Y"]);
        let lock = LockFile::from_config(&config);

        let serialized = toml::to_string_pretty(&lock).unwrap();
        let deserialized = LockFile::from_str(&serialized).unwrap();

        assert_eq!(lock.entries.len(), deserialized.entries.len());
        for (a, b) in lock.entries.iter().zip(deserialized.entries.iter()) {
            assert_eq!(a, b);
        }
    }

    #[test]
    fn diff_detects_removed() {
        let config_v1 = make_config(&["A.B", "X.Y"]);
        let lock = LockFile::from_config(&config_v1);

        // V2 removes X.Y
        let config_v2 = make_config(&["A.B"]);
        let diff = lock.diff(&config_v2);

        assert!(diff.removed.contains(&"X".to_string()));
        assert!(diff.removed.contains(&"X.Y".to_string()));
        assert!(diff.added.is_empty());
    }

    #[test]
    fn diff_detects_added() {
        let config_v1 = make_config(&["A.B"]);
        let lock = LockFile::from_config(&config_v1);

        // V2 adds X.Y
        let config_v2 = make_config(&["A.B", "X.Y"]);
        let diff = lock.diff(&config_v2);

        assert!(diff.removed.is_empty());
        assert!(diff.added.contains(&"X".to_string()));
        assert!(diff.added.contains(&"X.Y".to_string()));
    }

    #[test]
    fn diff_no_change() {
        let config = make_config(&["A.B", "X.Y"]);
        let lock = LockFile::from_config(&config);

        let diff = lock.diff(&config);

        assert!(diff.removed.is_empty());
        assert!(diff.added.is_empty());
    }

    #[test]
    fn add_entry_deduplicates() {
        let config = make_config(&["A.B"]);
        let mut lock = LockFile::from_config(&config);

        let original_len = lock.entries.len();

        // Try to add existing entry
        lock.add_entry(TagEntry {
            path: "A".to_string(),
            depth: 0,
            parent: None,
        });

        assert_eq!(lock.entries.len(), original_len);
    }

    #[test]
    fn rejects_future_schema() {
        let toml = r#"
schema_version = 999
generated_at = "2025-01-01T00:00:00Z"
entries = []
"#;
        let result = LockFile::from_str(toml);
        assert!(matches!(result, Err(LockFileError::SchemaVersion { .. })));
    }
}
